BGN EUR 10x20 Basis Swap – ficclib vs molib Calculation Mapping
================================================================

Context: BGN EURIBOR3M/EURIBOR6M 10x20 basis swap, notional $N$, valuation or curve date $t_0$.
Pay leg: 6M EURIBOR, Receive leg: 3M EURIBOR, discounting: ESTR OIS (BGN).

This note maps

quotes → curves → schedule → cashflows → spread

for the ficclib (Airflow) implementation versus the molib (Go) implementation, using a single fixed date and the 10x20 structure.

----------------------------------------------------------------

1. Setup and notation
----------------------

Common trade parameters:

- Valuation or curve date: $t_0$
- Trade date: $T_{trade} = t_0$
- Spot date: $T_{spot} = T_{trade} + 2$ TARGET business days
- Forward tenor: 10 years
- Swap tenor: 20 years
- Effective date:
  - Approximately $T_{eff} \approx T_{spot} + 10$ years (calendar plus business day adjustment)
- Maturity date:
  - Approximately $T_{mat} \approx T_{eff} + 20$ years
- Notional: $N = 10{,}000{,}000$
- Pay leg: 6M EURIBOR floating
- Receive leg: 3M EURIBOR floating
- Discounting: OIS (ESTR) for both legs

We use:

- $D(t)$: OIS discount factor from $t_0$ to $t$
- $P_6(t), P_3(t)$: 6M and 3M projection pseudo-discount factors
- $\delta^{(6)}_i, \delta^{(3)}_j$: accrual fractions for pay and receive coupons
- $f^{(6)}_i, f^{(3)}_j$: IBOR forward rates for each coupon period
- $s$: receive-leg spread in basis points, $s_{\text{dec}} = s / 10{,}000$

----------------------------------------------------------------

2. OIS curve (ESTR BGN)
-----------------------

### 2.1 ficclib (Airflow path)

Code path conceptually:

- Airflow include module prepares OIS quotes from marketdata.curves for source BGN and reference index ESTR.
- Ficclib functions prepare OIS quotes and pass them to an OIS bootstrapper.

Input quotes:

- For tenors $\tau_k$ such as 1Y, 2Y, 5Y, 10Y, 20Y, database provides par OIS swap rates $r^{OIS}_k$ in basis points.
- Ficclib converts to decimals
  $$
  q_k = \frac{r^{OIS}_k}{100}.
  $$

For each quote, ficclib computes a maturity date
$$
T^{OIS}_k
  = \text{compute\_maturity}(t_0, \tau_k;\ \text{TARGET},\ \text{spot lag}=2,\ \text{BDA},\ \text{EOM rule})
$$
using the ESTR floating leg conventions (TARGET calendar, appropriate roll convention, two-day spot).

Bootstrap:

- OISBootstrapper builds a curve of discount factors $D^{\text{F}}(t)$ from $t_0$ using QuantLib OIS instruments.
- Day count for the curve is ACT/365F.
- Swap equations are solved so that each par OIS quote is matched exactly.
- Interpolation is done in log-discount-factor space on an ACT/365F time axis (step-forward style).

We denote the resulting curve as
$$
D^{\text{F}}(t) = D_{\text{ESTR}}^{\text{ficc}}(t),\quad t \ge t_0.
$$

### 2.2 molib

Code path conceptually:

- molib uses fixture maps for BGN ESTR quotes.
- The function BuildCurve(curveDate, oisQuotes, TARGET, 1) constructs an OIS curve.

Input quotes:

- Fixture data provide a map from tenor strings $\tau_k$ (1Y, 2Y, 5Y, …) to par rates in percent $R^{OIS}_k$.
- molib converts them to decimals
  $$
  r^{OIS}_k = \frac{R^{OIS}_k}{100}.
  $$
- Tenors are mapped to year fractions
  $$
  u_k = \text{tenorToYears}(\tau_k).
  $$

Synthetic par schedule:

- BuildCurve creates a monthly payment grid
  $$
  S_i = \text{Adjust}\bigl(\text{TARGET}, t_0 + i \times 1\text{ month}\bigr),\quad i = 0,\dots,600,
  $$
  giving up to 50 years of monthly dates.
- A tenor mapping approximates each $S_i$ to a year fraction $u_i = i/12$.
- For each $S_i$ a par rate $\tilde r_i$ is defined:
  - If $u_i$ matches a quoted $u_k$, $\tilde r_i = r^{OIS}_k$.
  - Else, $\tilde r_i$ is linearly interpolated in rate space between neighboring quoted tenors, based on calendar days.

Bootstrap:

- Let quoted pillars be $S_{i_1} < \dots < S_{i_m}$ with par rates $\tilde r_{i_j}$.
- Discount factors $D^{\text{M}}(S_{i_j})$ are computed sequentially using a par swap equation:
  $$
  1 = \sum_{\ell=1}^{j-1} D^{\text{M}}(S_{i_\ell})\ \alpha_\ell\ \tilde r_{i_j}
      + D^{\text{M}}(S_{i_j}) (1 + \tilde r_{i_j} \alpha_j),
  $$
  where
  $$
  \alpha_\ell = \frac{\text{Days}(S_{i_{\ell-1}}, S_{i_\ell})}{365}.
  $$
- Between pillars, discount factors are interpolated log-linearly as a function of Days divided by 365 from $t_0$.

We denote
$$
D^{\text{M}}(t) = D_{\text{ESTR}}^{\text{mol}}(t),\quad t \ge t_0.
$$

Key OIS differences:

- ficclib uses true OIS instruments with ACT/365F and accurate ESTR conventions.
- molib uses a synthetic monthly par-swap bootstrap with accruals Days divided by 365 and interpolation in rate space, then log-discount factors.
- This leads to small systematic differences between $D^{\text{F}}(t)$ and $D^{\text{M}}(t)$.

----------------------------------------------------------------

3. IBOR curves (EURIBOR3M and EURIBOR6M)
----------------------------------------

### 3.1 ficclib

Ficclib uses IborCurveBuilder with the OIS curve from above as discounting curve. Input IBOR data:

- For each tenor $\tau_k$ (deposits and swaps) for EURIBOR3M and EURIBOR6M, ficclib receives par rates $q^{3M}_k, q^{6M}_k$ in decimals and constructs instruments (deposits and swaps).

Bootstrap:

- A dual-curve bootstrap engine takes:
  - OIS discount curve $D^{\text{F}}(t)$,
  - a set of deposit instruments,
  - a set of swap instruments for each index.
- It bootstraps pseudo-discount factors $P_3^{\text{F}}(t)$ and $P_6^{\text{F}}(t)$ so that:
  - Deposits are priced at par.
  - For each swap tenor, floating leg PV (built with accurate IBOR schedules and ACT/360) equals fixed leg PV, both discounted at $D^{\text{F}}(t)$.
- Between pillars, pseudo-discount factors are interpolated step-forward in log-DF on an ACT/365F time axis.

Forwards:

- For a pay-leg period with adjusted accrual dates $A^{\text{F},6}_i, B^{\text{F},6}_i$, the tenor end date $E^{\text{F},6}_i$ is computed using a function that applies tenor months (6M) with proper EOM rules.
- The 6M forward is
  $$
  f^{\text{F},6}_i
    = \frac{P_6^{\text{F}}(A^{\text{F},6}_i) / P_6^{\text{F}}(E^{\text{F},6}_i) - 1}
           {\text{ACT/360}(A^{\text{F},6}_i, E^{\text{F},6}_i)}.
  $$
- Similarly for the 3M leg,
  $$
  f^{\text{F},3}_j
    = \frac{P_3^{\text{F}}(A^{\text{F},3}_j) / P_3^{\text{F}}(E^{\text{F},3}_j) - 1}
           {\text{ACT/360}(A^{\text{F},3}_j, E^{\text{F},3}_j)}.
  $$

### 3.2 molib

molib uses BuildDualCurve for each index, with the OIS curve $D^{\text{M}}(t)$ as discounting curve and a regular 3M or 6M grid as projection schedule.

Input IBOR fixture quotes:

- For each tenor string $\tau_k$ for EURIBOR3M and EURIBOR6M, maps provide par rates in percent $R^{3M}_k, R^{6M}_k$.
- They are converted to decimals
  $$
  r^{3M}_k = \frac{R^{3M}_k}{100},\quad r^{6M}_k = \frac{R^{6M}_k}{100}.
  $$

Synthetic IBOR par curves:

- For the 6M curve, BuildDualCurve creates a grid
  $$
  S^{(6)}_i = \text{Adjust}\bigl(t_0 + i \times 6\text{M}\bigr).
  $$
  Each $S^{(6)}_i$ is mapped to a tenor $u^{(6)}_i = 0.5 i$.
- For each $S^{(6)}_i$ a par rate $\tilde r^{6M}_i$ is defined by matching or interpolating the fixture quotes.
- An analogous grid and mapping is used for the 3M curve.

Dual-curve pseudo-DF bootstrap:

- For each quoted tenor on the 6M curve with maturity $T$ and par rate $\tilde r^{6M}(T)$:
  - Define synthetic floating periods on a regular 6M grid from settlement to $T$.
  - For each period $[U_k, U_{k+1}]$:
    - Accrual $\alpha_k = \text{Days}(U_k, U_{k+1}) / 365$.
    - Pseudo-discount factors $P_6^{\text{M}}(U_k), P_6^{\text{M}}(U_{k+1})$ derived from the current pseudo-DF map.
    - Forward
      $$
      f^{\text{M},6}_k = \frac{P_6^{\text{M}}(U_k) / P_6^{\text{M}}(U_{k+1}) - 1}{\alpha_k}.
      $$
    - OIS DF $D^{\text{M}}(U_{k+1})$.
    - Floating PV contribution
      $$
      \text{floatPV} = \text{floatPV} + \alpha_k f^{\text{M},6}_k D^{\text{M}}(U_{k+1}).
      $$
  - Fixed leg:
    - Annual fixed coupons with rate $\tilde r^{6M}(T)$ from settlement to $T$ discounted with $D^{\text{M}}(t)$.
  - Solve for the unknown pseudo-DF at $T$ so that floating PV equals fixed PV.
- Between pillars, pseudo-DFs are interpolated log-linearly vs Days divided by 365.

The same pattern holds for the 3M curve, on a 3M grid.

Forwards used in pricing:

- For a pay-leg coupon with schedule period $[A^{\text{M},6}_i, B^{\text{M},6}_i]$ and tenor end
  $$
  E^{\text{M},6}_i = \text{Adjust}(A^{\text{M},6}_i + 6\text{M}),
  $$
  molib uses
  $$
  f^{\text{M},6}_i
    = \frac{P_6^{\text{M}}(A^{\text{M},6}_i) / P_6^{\text{M}}(E^{\text{M},6}_i) - 1}
           {\text{YearFraction}(A^{\text{M},6}_i, E^{\text{M},6}_i, \text{"ACT/360"})}.
  $$
- For a rec-leg coupon with 3M tenor end
  $$
  E^{\text{M},3}_j = \text{Adjust}(A^{\text{M},3}_j + 3\text{M}),
  $$
  molib uses
  $$
  f^{\text{M},3}_j
    = \frac{P_3^{\text{M}}(A^{\text{M},3}_j) / P_3^{\text{M}}(E^{\text{M},3}_j) - 1}
           {\text{YearFraction}(A^{\text{M},3}_j, E^{\text{M},3}_j, \text{"ACT/360"})}.
  $$

Key IBOR differences:

- Ficclib calibrates to real IBOR instruments with realistic schedules and ACT/360 daycounts.
- molib calibrates to synthetic IBOR swaps on regular 3M/6M grids with annual fixed legs and Days divided by 365 for the time axis.
- This changes the shapes of $P_3(t), P_6(t)$ and hence the forwards $f^{(3)}_j, f^{(6)}_i$.

----------------------------------------------------------------

4. Effective and maturity dates for 10x20
----------------------------------------

Ficclib:

- Effective date:
  - Computed as business-day-adjusted $(T_{spot} + 10\ \text{years})$ using a compute-maturity function and calendar add business days.
- Maturity date:
  - Computed as business-day-adjusted $(T_{eff} + 20\ \text{years})$.

molib:

- Effective date:
  - $T_{eff}^{\text{M}} = \text{AddYearsWithRoll}(\text{TARGET}, T_{spot}, 10)$.
- Maturity date:
  - $T_{mat}^{\text{M}} = \text{AddYearsWithRoll}(\text{TARGET}, T_{eff}^{\text{M}}, 20)$.

Both use forward years from spot then swap tenor from effective; differences are in the exact backward end-of-month and modified following rules between the two implementations.

----------------------------------------------------------------

5. Schedules for 10x20
----------------------

### 5.1 ficclib schedules

Ficclib uses a schedule builder that:

- For floating legs:
  - Builds a forward schedule from effective date to maturity date, stepping by the payment frequency (6M or 3M), with an end-of-month rule when applicable.
  - For each period:
    - $A^{\text{F}}_i, B^{\text{F}}_i$ are unadjusted start and end.
    - Accrual start and end are adjusted using the business day adjustment and TARGET calendar.
    - Payment date is adjusted end with any pay delay.
    - Reset and fixing dates depend on reset position and fixing lag.

This yields pay-leg dates $T^{\text{F},6}_i$ and rec-leg dates $T^{\text{F},3}_j$ that are closely aligned with SWPM.

### 5.2 molib schedules

molib uses buildSchedule:

- Start at effective date.
- At each step:
  - Compute next = start + 6M (or 3M for the rec leg).
  - Stop when next is after maturity plus one day.
  - Accrual start and end:
    - $\hat A_i^{\text{M}} = \text{Adjust}(\text{TARGET}, \text{start})$,
    - $\hat B_i^{\text{M}} = \text{Adjust}(\text{TARGET}, \text{next})$.
  - Reset date $R_i^{\text{M}}$ = business-day-adjusted accrual start minus fixing lag.
  - Payment date $T^{\text{M}}_i = \text{AddBusinessDays}(\text{TARGET}, \hat B_i^{\text{M}}, \text{payDelay})$.
  - Set start = next and repeat.

The resulting schedules are very close but not identical to ficclib’s; differences show up around end-of-months and stubs near maturity.

----------------------------------------------------------------

6. Cashflow algebra for 10x20
-----------------------------

The ficclib and molib implementations ultimately solve the same abstract equation per unit notional:
$$
0 = PV_{\text{pay}} + PV_{\text{rec}}(s),
$$
with
$$
PV_{\text{pay}} = -\sum_{i=1}^{n_6} \delta^{(6)}_i f^{(6)}_i D(T^{(6)}_i) + PV_{\text{prin}}^{\text{pay}},
$$
$$
PV_{\text{rec}}(s) = \sum_{j=1}^{n_3} \delta^{(3)}_j \bigl(f^{(3)}_j + s_{\text{dec}}\bigr) D(T^{(3)}_j) + PV_{\text{prin}}^{\text{rec}}.
$$

Where the symbols have implementation-specific definitions:

- In ficclib:
  - $D(t) = D^{\text{F}}(t)$ from the QuantLib ESTR OIS curve.
  - $f^{(6)}_i, f^{(3)}_j = f^{\text{F},6}_i, f^{\text{F},3}_j$ from the ficclib dual-curve IBOR bootstraps and SWPM-like schedules.
- In molib:
  - $D(t) = D^{\text{M}}(t)$ from the synthetic monthly par-swap OIS bootstrap.
  - $f^{(6)}_i, f^{(3)}_j = f^{\text{M},6}_i, f^{\text{M},3}_j$ from BuildDualCurve’s pseudo-DFs and simpler schedules.

Because the solve-for-spread equation is identical in form in both stacks, any difference in the 10x20 spread between ficclib and molib comes entirely from:

1. Differences in $D(t)$ (OIS curve shape).
2. Differences in $P_6(t), P_3(t)$ and thus $f^{(6)}_i, f^{(3)}_j$ (IBOR curve shapes).
3. Differences in the schedule dates $A_i, B_i, T_i$ and accruals $\delta_i$.
4. Any residual differences in principal timing and discounting (small compared to the above).

For BGN EUR 10x20, these methodological differences explain why:

- Airflow or ficclib spreads (as stored in pricing.basis_swap) closely match Bloomberg SWPM.
- molib spreads, while conceptually aligned, can show small systematic deviations (typically well under 0.5 basis points) due to approximations in OIS and IBOR curve construction and schedule generation.

